<!DOCTYPE html>

<html lang="fr">
	<head>
	  <meta charset="utf-8"/>
	  <meta name="viewport" content="width=device-width, initial-scale=1"/>

	  <!-- SEO PRINCIPAL : IoT + API D'ABORD -->
	  <title>API HTTP JSON IoT ESP32 – Mesure RMS double canal et tracé graphique | JAK Services</title>
	  <meta name="description" content="Construisez un nœud capteur IoT ESP32 exposant des mesures true RMS double canal et un tracé graphique via une API HTTP JSON stable. Firmware ESP-IDF (C) avec provisioning Wi-Fi, tests curl et intégration réseau local pour Grafana, InfluxDB, Home Assistant et Node-RED."/>
	  <meta name="robots" content="index,follow,max-image-preview:large"/>

	  <!-- Styles / icônes -->
	  <link rel="stylesheet" href="../styles/styles.css"/>
	  <link rel="stylesheet" href="../styles/portfolio_carousel.css"/>
	  <link rel="icon" href="/favicon.ico" type="image/x-icon"/>

	  <!-- Canonical + i18n -->
	  <link rel="canonical" href="https://jak-services.github.io/fr/tutorial_esp32_adc_wifi_api.html"/>
	  <link rel="alternate" hreflang="en" href="https://jak-services.github.io/en/tutorial_esp32_adc_wifi_api.html"/>
	  <link rel="alternate" hreflang="fr" href="https://jak-services.github.io/fr/tutorial_esp32_adc_wifi_api.html"/>
	  <link rel="alternate" hreflang="x-default" href="https://jak-services.github.io/en/tutorial_esp32_adc_wifi_api.html"/>

	  <!-- Open Graph (IoT-first, partageable) -->
	  <meta property="og:type" content="article"/>
	  <meta property="og:title" content="API HTTP JSON IoT ESP32 – Mesure RMS double canal et tracé graphique"/>
	  <meta property="og:description" content="Capteur IoT ESP32 auto-hébergé exposant des mesures RMS double canal et un tracé graphique via une API HTTP JSON. Firmware ESP-IDF avec provisioning Wi-Fi et tests curl — prêt pour Grafana, InfluxDB, Home Assistant et Node-RED."/>
	  <meta property="og:url" content="https://jak-services.github.io/fr/tutorial_esp32_adc_wifi_api.html"/>
	  <meta property="og:image" content="https://jak-services.github.io/images/tutorials/esp32_adc_wifi_2.webp"/>
	  <meta property="og:site_name" content="JAK Services"/>

	  <!-- Twitter -->
	  <meta name="twitter:card" content="summary_large_image"/>
	  <meta name="twitter:title" content="API HTTP JSON IoT ESP32 – Mesure RMS double canal et tracé graphique"/>
	  <meta name="twitter:description" content="Exposez des mesures true RMS et un tracé graphique depuis un nœud IoT ESP32 via une API HTTP JSON claire. Provisioning Wi-Fi + firmware ESP-IDF, prêt pour les dashboards et l’automatisation."/>
	  <meta name="twitter:image" content="https://jak-services.github.io/images/tutorials/esp32_adc_wifi_2.webp"/>

	  <!-- Données structurées -->
	  <script type="application/ld+json">
	  {
		"@context": "https://schema.org",
		"@type": "TechArticle",
		"headline": "API HTTP JSON IoT ESP32 – Mesure RMS double canal (ESP-IDF)",
		"description": "Construisez un nœud capteur IoT ESP32 auto-hébergé qui calcule du true RMS double canal et un tracé graphique, et expose les dernières valeurs via une API HTTP JSON stable. Inclut le provisioning Wi-Fi, ESP-IDF (C) et des tests curl pour l’automatisation et les dashboards.",
		"image": "https://jak-services.github.io/images/tutorials/esp32_adc_wifi_2.webp",
		"author": {
		  "@type": "Organization",
		  "name": "JAK Services"
		},
		"publisher": {
		  "@type": "Organization",
		  "name": "JAK Services",
		  "logo": {
			"@type": "ImageObject",
			"url": "https://jak-services.github.io/images/jak-logo.svg"
		  }
		},
		"mainEntityOfPage": {
		  "@type": "WebPage",
		  "@id": "https://jak-services.github.io/fr/tutorial_esp32_adc_wifi_api.html"
		},
		"about": [
		  "IoT",
		  "ESP32",
		  "API HTTP",
		  "JSON",
		  "ESP-IDF",
		  "Mesure RMS",
		  "Tracé graphique",
		  "Edge computing"
		],
		"keywords": [
		  "ESP32 IoT",
		  "ESP32 API HTTP",
		  "ESP32 API JSON",
		  "nœud capteur IoT",
		  "mesure RMS",
		  "tracé graphique",
		  "Grafana",
		  "InfluxDB",
		  "Home Assistant",
		  "Node-RED"
		]
	  }
	  </script>

	  <!-- Analytics -->
	  <script async data-goatcounter="https://jak-services.goatcounter.com/count" src="//gc.zgo.at/count.js"></script>
	</head>

	<body>
		<header class="site-header">
		  <div class="container header-inner">
			<a class="brand" href="index.html">
			  <img alt="Logo JAK Services" class="logo" src="../images/jak-logo.svg"/>
			  <div class="brand-text">
				<span class="brand-name">JAK Services</span>
				<span class="brand-tagline">Solutions d’ingénierie logicielle et électronique</span>
			  </div>
			</a>

			<nav class="main-nav">
			  <a href="index.html">Accueil / À propos</a>
			  <a href="services.html">Services</a>
			  <a href="portefolio.html">Portfolio</a>
			  <a href="tutorials.html" aria-current="page">Tutoriels</a>
			  <a href="../en/pcb-design-rules.html">Guides</a>
			  <a href="clients.html">Clients</a>
			  <a href="contact.html">Contact</a>
			</nav>

			<div class="lang-switch" aria-label="Sélecteur de langue">
			  <a class="lang-btn active" aria-current="true" href="../fr/tutorial_esp32_adc_wifi_api.html">FR</a>
			  <a class="lang-btn" href="../en/tutorial_esp32_adc_wifi_api.html">EN</a>
			</div>
		  </div>
		</header>

		<main class="container">
			<section class="hero">
			  <h1>API IoT ESP32 – Tracé graphique et mesure RMS double canal</h1>

			  <p class="lead">
                Construisez un <strong>nœud de mesure IoT auto-hébergé</strong> : l’ESP32 calcule en continu le true RMS et le tracé graphique sur deux canaux analogiques, et expose les dernières valeurs via une <strong>API HTTP JSON propre</strong> pour scripts, dashboards et automatisation.
              </p>

              <p style="margin-top:10px; margin-bottom:8px;">
                <strong>Une fois connecté au Wi-Fi :</strong> l’ESP32 expose les dernières mesures RMS et le tracé graphique via un endpoint HTTP JSON local, accessible depuis n’importe quel appareil du même réseau.
              </p>

              <div class="code-wrapper" style="margin-top:8px;">
                <button class="copy-btn" data-target="hero-curl" aria-label="Copier le code" title="Copier">⧉</button>
                <pre class="code-block"><code id="hero-curl">curl http://&lt;ESP32_IP&gt;/api/rms</code></pre>
              </div>

              <div class="code-wrapper" style="margin-top:10px;">
                <button class="copy-btn" data-target="hero-json" aria-label="Copier le code" title="Copier">⧉</button>
                <pre class="code-block"><code id="hero-json">{
  "channel_a_rms": 0.212,
  "channel_b_rms": 0.106,
  "unit": "volts",
  "timestamp_ms": 41596000
}</code></pre>
              </div>


			  <div class="carousel" aria-label="Points clés du tutoriel">
				<div class="carousel-track">
				  <div class="carousel-slide active">
					<p class="carousel-caption">IoT, API de mesure RMS (double ADC) &amp; tracé graphique</p>
					<div class="carousel-image-wrapper">
					  <a href="tutorial_esp32_adc_wifi_api.html">
						<img
						  src="/images/tutorials/esp32_adc_wifi_2.webp"
						  alt="Illustration IoT, API de mesure RMS (double ADC) & tracé graphique"
						  loading="lazy"
						  decoding="async"
						/>
					  </a>
					</div>
				  </div>

				  <div class="carousel-slide">
					<p class="carousel-caption">Connectez l’ESP32 à votre réseau Wi-Fi domestique.</p>
					<div class="carousel-image-wrapper">
					  <a href="tutorial_esp32_adc_wifi_api.html">
						<img
						  src="/images/tutorials/esp32_adc_wifi_0.webp"
						  alt="Image : connecter l’ESP32 à votre réseau Wi-Fi domestique"
						  loading="eager"
						  decoding="async"
						/>
					  </a>
					</div>
				  </div>

				  <div class="carousel-slide">
					<p class="carousel-caption">Récupérez l’adresse IP attribuée à l’ESP32 par votre réseau Wi-Fi domestique.</p>
					<div class="carousel-image-wrapper">
					  <a href="tutorial_esp32_adc_wifi_api.html">
						<img
						  src="/images/tutorials/esp32_adc_wifi_1.webp"
						  alt="Illustration : récupérer l’adresse IP attribuée à l’ESP32"
						  loading="lazy"
						  decoding="async"
						/>
					  </a>
					</div>
				  </div>

				  <div class="carousel-slide">
					<p class="carousel-caption">Maquette de prototype</p>
					<div class="carousel-image-wrapper">
					  <a href="tutorial_esp32_adc_wifi_api.html">
						<img
						  src="/images/tutorials/esp32_adc.webp"
						  alt="Illustration : maquette de prototype"
						  loading="lazy"
						  decoding="async"
						/>
					  </a>
					</div>
				  </div>
				</div>

				<!-- IMPORTANT : correspondre aux sélecteurs de carousel.js -->
				<button class="carousel-btn prev" type="button" aria-label="Diapositive précédente">‹</button>
				<button class="carousel-btn next" type="button" aria-label="Diapositive suivante">›</button>
				<button aria-pressed="false" class="carousel-toggle" title="Mettre en pause ou reprendre le diaporama" type="button">Pause</button>

				<!-- IMPORTANT : 4 diapositives = 4 points -->
				<div class="carousel-dots" role="tablist" aria-label="Navigation du carrousel">
				  <button class="dot active" type="button" data-index="0" aria-current="true" aria-label="IoT, API de mesure RMS (double ADC) & Tracé graphique" title="IoT, API de mesure RMS (double ADC) & Tracé graphique"></button>
				  <button class="dot" type="button" data-index="1" aria-label="Connecter l’ESP32 à votre réseau Wi-Fi domestique" title="Connecter l’ESP32 à votre réseau Wi-Fi domestique"></button>
				  <button class="dot" type="button" data-index="2" aria-label="Récupérer l’adresse IP attribuée à l’ESP32 par votre réseau Wi-Fi domestique." title="Récupérer l’adresse IP attribuée à l’ESP32 par votre réseau Wi-Fi domestique."></button>
				  <button class="dot" type="button" data-index="3" aria-label="Maquette de prototype" title="Maquette de prototype"></button>
				</div>
			  </div>

			  <p class="tutorial-meta">
				Carte : ESP32 DevKitC (ESP32-WROOM-32) &bull; Langage : C (ESP-IDF) &bull; IDE : Visual Studio Code &bull; Sortie : API HTTP JSON
			  </p>

			  <div class="hero-actions">
				<a class="btn secondary" href="tutorials.html">&larr; Retour aux tutoriels</a>
				<a class="btn primary" href="#get-the-code">Récupérer le code</a>
			  </div>
			</section>

			<section class="card toc">
			  <h2>Sommaire</h2>
			  <nav aria-label="Sommaire du tutoriel">
				<ul class="toc-list">
				  <li><a href="#overview">Vue d’ensemble</a></li>
				  <li><a href="#api">API HTTP (JSON)</a></li>
				  <li><a href="#architecture">Architecture en un coup d’œil</a></li>
				  <li><a href="#what-you-need">Pré-requis</a></li>
				  <li><a href="#wiring">Câblage (GPIO34 / GPIO35)</a></li>
				  <li><a href="#vscode">Configuration VS Code + ESP-IDF</a></li>
				  <li><a href="#get-the-code">Récupérer le code (GitHub)</a></li>
				  <li><a href="#project">Compiler le projet</a></li>
				  <li><a href="#firmware-tour">Tour du firmware : Démarrage → Mesure → Service</a></li>
				  <li><a href="#provisioning">Provisioning Wi-Fi</a></li>
				  <li><a href="#flash">Compiler, flasher, monitorer, déboguer</a></li>
				  <li><a href="#troubleshooting">Dépannage</a></li>
				  <li><a href="#resources">Ressources</a></li>
				</ul>
			  </nav>
			</section>

			<section id="overview" class="card">
          <h2>Vue d’ensemble</h2>

          <p>
            L’objectif de ce projet est <strong>API-first</strong> : transformer un ESP32 en un petit <strong>nœud capteur IoT</strong> fiable qui publie
            des <strong>mesures RMS et un tracé graphique lisibles par machine</strong> sur votre réseau local. L’ADC et les calculs RMS sont le “backend capteur” &mdash; le
            endpoint HTTP JSON est le produit que vous intégrez dans vos outils et dashboards.
          </p>

          <p class="callout">
            Cette API HTTP est conçue pour une <strong>consommation machine</strong> (scripts, automatisation, dashboards), pas seulement pour des tests manuels.
          </p>

          <h3>Ce que cette API permet</h3>
          <ul>
            <li>Interroger les valeurs depuis des scripts et outils (<code>curl</code>, Python, Go, Bash, CI checks, etc.).</li>
            <li>Alimenter une chaîne time-series (Node-RED &rarr; InfluxDB/Prometheus &rarr; Grafana).</li>
            <li>Intégrer en automatisation domestique/industrielle (Home Assistant, passerelles PLC, services sur mesure).</li>
            <li>Utiliser l’ESP32 comme un <strong>endpoint de mesure headless</strong> déployable partout sur votre LAN.</li>
          </ul>

          <h3>Ce que fait ce projet</h3>
          <ul>
            <li>Fournit un <strong>provisioning Wi-Fi</strong> pour la configuration au premier démarrage.</li>
            <li>Échantillonne <strong>deux entrées analogiques</strong> via <strong>ADC1</strong>.</li>
            <li>Calcule <strong>la tension true RMS et le tracé graphique</strong> sur une fenêtre de mesure.</li>
            <li>Met à jour les résultats périodiquement (par ex. toutes les 1&ndash;10 secondes).</li>
            <li>Expose en continu les dernières valeurs via une <strong>API HTTP JSON stable</strong>.</li>
          </ul>

          <h3>Ce que ce projet n’est pas</h3>
          <ul>
            <li>Pas de streaming continu des échantillons bruts.</li>
            <li>Pas de visualisation “oscilloscope” dans Telemetry Viewer.</li>
          </ul>

          <p class="callout">
            Si vous avez besoin d’un tracé temps réel de la forme d’onde via USB, utilisez le tutoriel dédié :
            <a href="tutorial_esp32_dual_adc_serial_oscilloscope.html">Double ADC + Oscilloscope série (Telemetry Viewer)</a>.
          </p>
        </section>


			
            <section id="architecture" class="card">
              <h2>Architecture en un coup d’œil</h2>

              <p>
                Le firmware est structuré pour que le serveur HTTP réponde toujours rapidement : les mesures sont effectuées en arrière-plan et l’API sert
                le dernier résultat terminé depuis un cache partagé.
              </p>

              <div class="code-wrapper">
                <button class="copy-btn" data-target="arch-flow" aria-label="Copier le code" title="Copier">⧉</button>
                <pre class="code-block"><code id="arch-flow">ADC (CH_A, CH_B)
   ↓  fenêtre d’échantillonnage périodique
Tâche de calcul RMS
   ↓  mise à jour de l’état partagé (dernier résultat)
Serveur HTTP
   ↓
GET /api/rms  → JSON pour les clients (curl / Node-RED / Grafana / apps)</code></pre>
              </div>

              <p class="callout">
                Choix clé : l’appareil <strong>ne</strong> mesure <strong>pas</strong> “à la demande”. Les requêtes renvoient simplement le RMS de la dernière fenêtre terminée,
                ce qui garde le Wi-Fi réactif et des temps de réponse constants.
              </p>
            </section>

			<section id="what-you-need" class="card">
			  <h2>Pré-requis</h2>
			  <ul>
				<li>ESP32 DevKitC (ESP32-WROOM-32) ou carte ESP32 similaire.</li>
				<li>Deux signaux analogiques (0&ndash;3,3 V). <a href="https://youtu.be/zW5jnChzPlY" target="_blank" rel="noopener">Voir ce tutoriel vidéo pour un exemple de circuit.</a>.</li>
				<li>Câble USB pour flasher et lire les logs série.</li>
				<li>Un téléphone ou un ordinateur pour se connecter au portail de provisioning.</li>
			  </ul>

			  <p class="callout">
				Les entrées ADC de l’ESP32 doivent rester dans <strong>0&ndash;3,3 V</strong>. Ne dépassez jamais 3,3 V sur GPIO34/GPIO35.
			  </p>
			</section>

			<section id="wiring" class="card">
			  <h2>Câblage (GPIO34 / GPIO35)</h2>
			  <p>
				Ce tutoriel utilise volontairement <strong>ADC1 uniquement</strong> afin d’éviter les conflits ADC2/Wi-Fi.
			  </p>

			  <div class="table-wrapper">
				<table class="table">
				  <thead>
					<tr>
					  <th>Canal</th>
					  <th>GPIO</th>
					  <th>Unité ADC</th>
					  <th>Notes</th>
					</tr>
				  </thead>
				  <tbody>
					<tr>
					  <td>CH_A</td>
					  <td>GPIO34</td>
					  <td>ADC1</td>
					  <td>Broche entrée uniquement (idéale pour l’ADC)</td>
					</tr>
					<tr>
					  <td>CH_B</td>
					  <td>GPIO35</td>
					  <td>ADC1</td>
					  <td>Broche entrée uniquement (idéale pour l’ADC)</td>
					</tr>
				  </tbody>
				</table>
			  </div>

			  <p class="callout">
				Reliez la <strong>masse du signal</strong> au <strong>GND</strong> de l’ESP32, sinon les mesures seront instables et sans signification.
			  </p>
			</section>

			<section id="vscode" class="card">
			  <h2>Configuration VS Code + ESP-IDF</h2>
			  <p>
				Installez ESP-IDF et l’extension VS Code exactement comme dans le <a href="tutorial_esp32_dual_adc_serial_oscilloscope.html">tutoriel oscilloscope série</a>.
				Si ESP-IDF est déjà installé, vous pouvez passer directement au clonage du projet.
			  </p>

			  <ul>
				<li>Installer Visual Studio Code</li>
				<li>Installer l’extension <strong>Espressif IDF</strong></li>
				<li>Lancer l’assistant de configuration ESP-IDF (toolchain + Python + IDF)</li>
			  </ul>

			  <p class="callout">
				Utilisez une version stable d’ESP-IDF et gardez-la cohérente entre vos projets. Ce tutoriel a été développé avec Visual Studio Code v1.108.1 et ESP-IDF v1.11.1.
			  </p>
			</section>

			<section id="get-the-code" class="card">
			  <h2>Récupérer le code (GitHub)</h2>

			  <p>
				Le firmware complet de ce tutoriel est disponible sur GitHub :
				<a href="https://github.com/jak-services/esp32-adc-rms-wifi-api" target="_blank" rel="noopener noreferrer">
				  esp32-dual-adc-rms-wifi
				</a>
				<span style="opacity:0.8;"></span>
			  </p>

			  <div class="hero-actions" style="justify-content:flex-start;">
				<a class="btn secondary" href="https://github.com/jak-services/esp32-adc-rms-wifi-api" target="_blank" rel="noopener noreferrer">
				  Voir le dépôt
				</a>
				<a class="btn primary" href="https://github.com/jak-services/esp32-adc-rms-wifi-api/archive/refs/heads/main.zip" target="_blank" rel="noopener noreferrer">
				  Télécharger le ZIP
				</a>
				<a class="btn secondary" href="https://github.com/jak-services/esp32-adc-rms-wifi-api/releases/latest" target="_blank" rel="noopener noreferrer">
				  Dernière release
				</a>
			  </div>

			  <p style="margin-top:12px; margin-bottom:8px;">Cloner en local :</p>

			  <div class="code-wrapper">
				<button class="copy-btn" data-target="clone-code" aria-label="Copier le code" title="Copier">⧉</button>
				<pre class="code-block"><code id="clone-code">git clone https://github.com/jak-services/esp32-adc-rms-wifi-api.git
cd esp32-adc-rms-wifi-api</code></pre>
			  </div>
			</section>

			<section id="project" class="card">
			  <h2>Compiler le projet</h2>
			  <p>
				C’est un projet ESP-IDF standard (CMake). Ouvrez le dossier dans VS Code et utilisez les commandes ESP-IDF.
			  </p>

			  <ol>
				<li>Ouvrir VS Code dans le dossier du projet.</li>
				<li>Définir la cible (si nécessaire, CTRL + SHIFT + P) : <strong>ESP-IDF: Set Espressif Device Target</strong> &rarr; <strong>esp32</strong>.</li>
				<li>Configurer le port série (CTRL + SHIFT + P) : <strong>ESP-IDF: Select Port to Use</strong>.</li>
				<li>Compiler/Flasher (CTRL + SHIFT + P) : <strong>ESP-IDF: Build, Flash and Start a Monitor on Your Device</strong>.</li>
			  </ol>

			  <p class="callout">
				La plupart des cartes DevKitC entrent automatiquement en bootloader. Si le flash reste bloqué sur “Connecting…”, maintenez <strong>BOOT</strong>,
				cliquez sur flash, puis relâchez BOOT quand vous voyez “Writing at …”.
			  </p>
			</section>

			<section id="firmware-tour" class="card">
			  <h2>Tour du firmware : Démarrage → Mesure → Service</h2>

			  <p>
				Ce projet est volontairement découpé en plusieurs fichiers pour garder chaque sous-système lisible :
				échantillonnage ADC, traitement RMS, provisioning, et serveur HTTP.
			  </p>

			  <h3>Flux global</h3>
			  <ol>
				<li><strong>Démarrage</strong> : initialiser NVS + logs.</li>
				<li><strong>Wi-Fi</strong> : se connecter (ou démarrer le provisioning si nécessaire).</li>
				<li><strong>Mesure</strong> : capturer périodiquement des échantillons et calculer le RMS.</li>
				<li><strong>Service</strong> : renvoyer instantanément le résultat en cache via HTTP.</li>
			  </ol>


			  <h3>Pseudo-point d’entrée (pour se repérer)</h3>
			  <p>
				L’idée est toujours la même :
				démarrer le Wi-Fi, démarrer la mesure, démarrer le serveur.
			  </p>

			  <div class="code-wrapper">
				<button class="copy-btn" data-target="main-flow" aria-label="Copier le code" title="Copier">⧉</button>
				<pre class="code-block"><code id="main-flow">// PSEUDO-CODE (illustration)

void app_main(void)
{
    nvs_init();
    wifi_init_and_connect_or_provision();

    measurements_init();         // allocate buffers, init ADC config
    measurements_start_task();   // periodic capture + RMS compute

    http_server_start();         // exposes /api/rms
}</code></pre>
			  </div>
			</section>

			<section id="provisioning" class="card">
				<h2>Provisioning Wi-Fi</h2>

				<p>
				  Au premier démarrage (ou lorsque aucun identifiant Wi-Fi n’est stocké), l’appareil démarre un
				  <strong>point d’accès Wi-Fi</strong> et expose un portail de provisioning.
				</p>

				<h3>Étapes typiques de provisioning</h3>
				<ol>
				  <li>Alimentez l’ESP32 via un câble USB.</li>

				  <li>
					Sur votre téléphone ou ordinateur, ouvrez les paramètres Wi-Fi et connectez-vous au point d’accès
					nommé <code>JAK_DEVICE_*</code>, avec le mot de passe
					<code>configureme</code> (modifiable dans le fichier <code>app_config.h</code>).
				  </li>

				  <li>
					Si la page de provisioning ne s’ouvre pas automatiquement, lancez un navigateur
					et allez à la page de configuration via l’adresse IP locale
					<code>http://192.168.4.1</code> (modifiable dans le fichier
					<code>app_config.h</code>).
				  </li>

				  <li>Saisissez le SSID et le mot de passe de votre Wi-Fi.</li>

				  <li>
					L’appareil enregistre les identifiants et se connecte à votre réseau Wi-Fi.
				  </li>
				</ol>

				<p class="callout">
				  Une fois connecté à votre Wi-Fi, l’ESP32 reçoit une adresse IP attribuée par votre
				  routeur. Cette adresse IP est affichée dans l’API.
				  <br><br>
				  À partir de là, vous pouvez accéder à l’ESP32 depuis n’importe quel téléphone ou ordinateur
				  connecté au même réseau Wi-Fi domestique en utilisant cette adresse IP, sans
				  devoir vous connecter au point d’accès <code>JAK_DEVICE_*</code>.
				  <br><br>
				  Le point d’accès de provisioning reste disponible en permanence si vous devez
				  reconfigurer l’appareil ou changer de réseau Wi-Fi.
				</p>

				<h3>Considérations de sécurité</h3>
				<p>
				  Le point d’accès de provisioning est protégé en WPA2 avec un mot de passe configurable,
				  ce qui empêche les connexions non autorisées pendant la configuration.
				  <br><br>
				  Tous les services fournis par l’appareil (interface de provisioning et API HTTP)
				  sont accessibles uniquement depuis le réseau local et ne sont pas exposés à
				  Internet. L’appareil n’initie aucune connexion externe et ne dépend pas de services cloud.
				  <br><br>
				  L’API HTTP n’implémente ni authentification ni chiffrement, et est destinée
				  à un usage sur un environnement local de confiance. Si une sécurité renforcée est requise
				  (par exemple HTTPS, authentification, ou accès restreint), des mesures supplémentaires,
				  non couvertes par ce tutoriel, doivent être implémentées.
				</p>
			</section>

			<section id="api" class="card">
			  <h2>API HTTP (JSON)</h2>
			  <p>
				L’API renvoie les <strong>dernières mesures RMS terminées et le tracé graphique</strong>. L’échantillonnage n’est pas déclenché à la demande,
				ce qui garantit des requêtes rapides et un Wi-Fi réactif.
			  </p>

			  <h3>Endpoint</h3>
			  <div class="code-wrapper">
				<button class="copy-btn" data-target="api-endpoint" aria-label="Copier le code" title="Copier">⧉</button>
				<pre class="code-block"><code id="api-endpoint">GET /api/rms</code></pre>
			  </div>

			  <h3>Exemple de réponse</h3>
			  <div class="code-wrapper">
				<button class="copy-btn" data-target="api-response" aria-label="Copier le code" title="Copier">⧉</button>
				<pre class="code-block"><code id="api-response">{
  "channel_a_rms": 1.237,
  "channel_b_rms": 0.982,
  "unit": "volts",
  "timestamp_ms": 12345678
}</code></pre>
			  </div>

			  <h3>Tester avec curl</h3>
			  <p>
				Une fois l’appareil connecté au Wi-Fi, trouvez son adresse IP dans l’API (ou dans les logs série), puis :
			  </p>

			  <div class="code-wrapper">
				<button class="copy-btn" data-target="curl-code" aria-label="Copier le code" title="Copier">⧉</button>
				<pre class="code-block"><code id="curl-code">curl http://&lt;ESP32_IP&gt;/api/rms</code></pre>
			  </div>

			  <p class="callout">
				Si vous prévoyez d’intégrer à des dashboards (Home Assistant, Node-RED, Grafana, etc.),
				gardez le JSON stable et versionnez l’API lorsque vous introduisez des changements incompatibles.
			  </p>
			</section>

			<section id="flash" class="card">
			  <h2>Compiler, flasher, monitorer, déboguer</h2>

			  <h3>Compiler + flasher</h3>
			  <ol>
				<li>Lancer (CTRL + SHIFT + P) : <strong>ESP-IDF: Full Clean Project</strong>.</li>
				<li>Lancer (CTRL + SHIFT + P) : <strong>ESP-IDF: Build, Flash and Start a Monitor on Your Device</strong>.</li>
			  </ol>

			  <h3>Moniteur série</h3>
			  <p>
				Utilisez (CTRL + SHIFT + P) <strong>ESP-IDF: Monitor</strong> pour vérifier :
			  </p>
			  <ul>
				<li>Le mode provisioning démarre (premier boot) OU le Wi-Fi se connecte (déjà provisionné)</li>
				<li>L’adresse IP est affichée</li>
				<li>La boucle de mesure tourne (logs périodiques “RMS updated”, si activés)</li>
				<li>Le serveur HTTP est en écoute</li>
			  </ul>

			  <p class="callout">
				Un seul programme peut ouvrir le port série à la fois. Fermez le moniteur (CTRL + T puis CTRL + X)
				si un autre outil doit utiliser le port.
			  </p>
			</section>

			<section id="troubleshooting" class="card">
			  <h2>Dépannage</h2>

			  <h3>Mesures instables / bruit</h3>
			  <ul>
				<li>Vérifiez que la masse du signal est bien reliée au GND de l’ESP32.</li>
				<li>Utilisez des fils courts et évitez un câblage “désordonné” sur breadboard pour les signaux faibles.</li>
				<li>Envisagez moyennage, filtrage et calibration (surtout si vous voulez des valeurs de tension précises).</li>
			  </ul>
			  
			  <h3>Impossible d’accéder à l’API après provisioning</h3>
			  <ul>
				  <li>Pendant la configuration initiale, connectez-vous au point d’accès <strong>JAK_DEVICE_*</strong> pour saisir le SSID et le mot de passe de votre Wi-Fi.</li>
				  <li>Une fois les identifiants enregistrés, déconnectez-vous de <strong>JAK_DEVICE_*</strong> et reconnectez votre appareil client au Wi-Fi de votre routeur.</li>
				  <li>L’API HTTP RMS est accessible uniquement lorsque l’ESP32 et votre client sont sur le même réseau domestique.</li>
				  <li>Utilisez l’adresse IP attribuée par le routeur (visible dans les logs série) pour accéder à l’API.</li>
			  </ul>

			  <h3>Le Wi-Fi se connecte mais l’API ne répond pas</h3>
			  <ul>
				  <li>Confirmez l’adresse IP dans les logs série.</li>
				  <li>Essayez <code>http://&lt;ip&gt;/api/rms</code> dans un navigateur.</li>
				  <li>Vérifiez que votre pare-feu / isolation réseau ne bloque pas le trafic local.</li>
				  <li>
					Si vous utilisez un téléphone, <strong>désactivez Wi-Fi roaming / Wi-Fi Assist / bascule données mobiles</strong>.
					Certains téléphones basculent automatiquement sur le cellulaire ou un autre point d’accès, ce qui empêche l’accès
					aux appareils du réseau local.
				  </li>
			  </ul>

			  <h3>Pourquoi ADC1 uniquement ?</h3>
			  <p class="callout">
				Sur ESP32, <strong>ADC2 est partagé avec le Wi-Fi</strong>. Utiliser ADC2 quand le Wi-Fi est actif peut produire des mesures invalides
				ou des erreurs. Ce projet utilise <strong>ADC1 uniquement</strong> pour une utilisation robuste.
			  </p>
			</section>

			<section id="resources" class="card">
			  <h2>Ressources</h2>
			  <ul>
				<li>Documentation Espressif : <a href="https://documentation.espressif.com" target="_blank" rel="noopener">documentation.espressif.com</a></li>
				<li>Guide de programmation ESP-IDF : <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/" target="_blank" rel="noopener">ESP-IDF (esp32)</a></li>
				<li>Visual Studio Code : <a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">Téléchargement Visual Studio Code</a></li>
			  </ul>
			</section>
		</main>

		<footer class="site-footer">
		  <div class="container footer-inner">
			<p>© <span id="year"></span> JAK Services – Toulouse, France</p>
			<p>
			  <a class="footer-link" href="legal.html">Mentions légales</a>
			  <a class="footer-link" href="privacy.html">Politique de confidentialité</a>
			</p>
		  </div>
		</footer>

		<script src="../js/main.js"></script>
		<script src="../js/tutorials.js"></script>
		<script src="../js/carousel.js"></script>
	</body>
</html>
